#!/bin/bash

# Runs Prettier on .ts, .tsx, .js, .jsx, .md, .yml, .yaml, .css and .json files, and also runs ESLint and tsc on .ts,
# .tsx, .js, .jsx files. Prettier and ESLint only check the committed files, whereas tsc checks all project files, since
# it's not possible to run tsc on specific files while obeying the tsconfig.json options (see
# https://github.com/microsoft/TypeScript/issues/27379 and https://www.npmjs.com/package/tsc-files).
# Runs `terraform fmt -check` and `terraform validate` on .tf and .tfvars files.
# Runs ShellCheck on .sh files if ShellCheck is installed.
# This hook always commits, even if errors are found. And it does not modify the files (ie it does not do `prettier
# write` or `terraform fmt`), it only checks if there is any issue and reports it.
# Inspired by https://prettier.io/docs/precommit.html#option-5-shell-script

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NO_COLOR='\033[0m'

# Validate that pre-commit and .git/hooks/pre-commit have the same content.
# If content is not the same, do not commit.
validate_precommit_hook() {
  if ! diff pre-commit .git/hooks/pre-commit > /dev/null; then
    printf "${RED}Error: pre-commit and .git/hooks/pre-commit have different content.${NO_COLOR}\n"
    printf "${BOLD}Commit aborted.${NO_COLOR}\n"
    printf "${YELLOW}To fix this, run: ${BOLD}cp pre-commit .git/hooks${NO_COLOR}\n"
    printf "${YELLOW}Then commit again.${NO_COLOR}\n"
    exit 1
  fi
}

validate_precommit_hook

get_staged_files() {
  ALL_FILES=$(git diff --cached --name-only --diff-filter=ACMR | sed 's| |\\ |g' | awk '/\.ts$|\.tsx$|\.js$|\.jsx$|\.md$|\.yml$|\.yaml$|\.html$|\.css$|\.json$|\.tf$|\.tfvars$|\.sh$|^pre-commit$/')
  ALL_CODE_FILES=$(echo "$ALL_FILES" | awk '/\.ts$|\.tsx$|\.js$|\.jsx$/')
  CODE_FILES_SERVER=$(echo "$ALL_CODE_FILES" | awk '/^server\//' | sed 's|^server/||')
  CODE_FILES_WEB=$(echo "$ALL_CODE_FILES" | awk '/^web\//' | sed 's|^web/||')
  TERRAFORM_FILES=$(echo "$ALL_FILES" | awk '/\.tf$|\.tfvars$/')
  SHELL_FILES=$(echo "$ALL_FILES" | awk '/\.sh$|^pre-commit$/')
}

print_title() {
  printf "\n\nðŸ” ${BLUE}%s${NO_COLOR}\n\n" "$1"
}

print_result() {
  ERROR_CODE=$?
  if [ $ERROR_CODE -eq 0 ]; then
    printf "\nâœ… ${GREEN}%s Success${NO_COLOR}\n\n" "$1"
  else
    printf "\nâŒ ${RED}%s Failure${NO_COLOR}\n\n" "$1"
  fi
}

get_staged_files

printf "ðŸ“ ${BLUE}Files${NO_COLOR}\n\n%s" "$ALL_FILES"
[ -z "$ALL_FILES" ] && exit 0

# Prettier on all files

print_title "Prettier"
echo "$ALL_FILES" | xargs ./node_modules/.bin/prettier --ignore-unknown --check
print_result "Prettier"

# ESLint and tsc on server code

if [ ! -z "$CODE_FILES_SERVER" ]; then
  cd server || exit 1

  printf "ðŸ“ Files server\n\n%s" "$CODE_FILES_SERVER"

  print_title "ESLint server"
  echo "$CODE_FILES_SERVER" | xargs ./node_modules/.bin/eslint
  print_result "ESLint server"

  print_title "tsc server"
  npx tsc --noEmit
  print_result "tsc server"

  cd ..
fi

# ESLint and tsc on web code

if [ ! -z "$CODE_FILES_WEB" ]; then
  cd web || exit 1

  printf "ðŸ“ Files web\n\n%s" "$CODE_FILES_WEB"

  print_title "ESLint web"
  echo "$CODE_FILES_WEB" | xargs ./node_modules/.bin/eslint
  print_result "ESLint web"

  print_title "tsc web"
  npx tsc --noEmit
  print_result "tsc web"

  cd ..
fi

# Terraform fmt and validate

if [ ! -z "$TERRAFORM_FILES" ]; then
  printf "ðŸ“ Files terraform\n\n%s" "$TERRAFORM_FILES"

  print_title "Terraform fmt"
  echo "$TERRAFORM_FILES" | xargs terraform fmt -check
  print_result "Terraform fmt"

  # Run terraform validate in initialized environment directories
  # Search for .terraform directories inside the terraform directory to identify initialized root modules
  find terraform -name ".terraform" -type d | while read -r provider_dir; do
    dir=$(dirname "$provider_dir")
    print_title "Terraform validate ($dir)"
    (cd "$dir" && terraform validate)
    print_result "Terraform validate ($dir)"
  done
fi

# ShellCheck

if [ ! -z "$SHELL_FILES" ]; then
  printf "ðŸ“ Files shell\n\n%s" "$SHELL_FILES"

  print_title "ShellCheck"
  if command -v shellcheck >/dev/null 2>&1; then
    SC_EXIT=0
    FAILED_SHELL_FILES=""
    while IFS= read -r file; do
      [ -z "$file" ] && continue
      if ! shellcheck "$file"; then
        SC_EXIT=1
        FAILED_SHELL_FILES="${FAILED_SHELL_FILES}${file}"$'\n'
      fi
    done <<< "$SHELL_FILES"

    if [ $SC_EXIT -ne 0 ]; then
      printf "\n${YELLOW}ShellCheck reported issues${NO_COLOR}\n"
      printf "${YELLOW}To check individual files, run:${NO_COLOR}\n"
      while IFS= read -r file; do
        [ -z "$file" ] && continue
        printf "${YELLOW}shellcheck %s${NO_COLOR}\n" "$file"
      done <<< "$FAILED_SHELL_FILES"
    fi
    [ $SC_EXIT -eq 0 ] # Set the exit code for print_result
    print_result "ShellCheck"
  else
    printf "${YELLOW}Shellcheck not found; skipping shell script linting. Install shellcheck to enable.${NO_COLOR}\n"
  fi
fi

# shfmt

if [ ! -z "$SHELL_FILES" ]; then
  print_title "shfmt"
  if command -v shfmt >/dev/null 2>&1; then
    UNFORMATTED_FILES=$(echo "$SHELL_FILES" | xargs shfmt -l -i 2 -ci -bn)
    if [ ! -z "$UNFORMATTED_FILES" ]; then
      SHFMT_EXIT=1
      printf "${YELLOW}shfmt found files that need formatting${NO_COLOR}\n"
      printf "${YELLOW}To format these files, run:${NO_COLOR}\n"
      while IFS= read -r file; do
        [ -z "$file" ] && continue
        printf "${YELLOW}shfmt -w -i 2 -ci -bn %s${NO_COLOR}\n" "$file"
      done <<< "$UNFORMATTED_FILES"
    else
      SHFMT_EXIT=0
    fi
    [ $SHFMT_EXIT -eq 0 ] # Set the exit code for print_result
    print_result "shfmt"
  else
    printf "${YELLOW}shfmt not found; skipping shell script formatting check. Install shfmt to enable.${NO_COLOR}\n"
  fi
fi

exit 0
